# Components

### Определения
* **Компонент** - это экземпляр javascript класса, в котором предопределены некоторые методы и свойства, а так же добавлены пользовательские методы. 
* **Корневой элемент** - HTML-узел, управляемый экземпляром компонента или контроллера
* **Контроллер** - Объект, управляющий созданием и поведением группы компонентов 

### Принцип работы
Компоненты не связаны друг с другом, но "знают" о контроллере, который их создает и управляет их поведением. Так же компоненты не должны ничего знать о каких-то элементах, которые находятся за пределами их корневого элемента. Контроллеру ничего не известно о компонентах. Любой компонент может быть удален из структуры и это не вызовет ошибку в работе других компонентов или контроллера.
Компоненты изменяют свойства контроллера, сообщая ему о каких-то изменениях в них. Контроллер следит за изменением своих свойств и в случае необходимости уведомляет подписаные на определенные события компоненты о произошедших изменениях. Так же контроллер следит за DOM-событиями на своем корневом элементе. Контроллер не должен иметь своих методов, его работа - следить за событиями DOM-дерева и состоянием своих свойств и извещать компоненты об изменениях, генерируя событвенные события. 

## Подключение

Для работы Components необходим библиотека Jquery.
Первым подключается файл Components.js, затем подключаются компоненты и в конце контроллер(ы)

## Создание компонента

Компонент создается следующей конструкцией:
```sh
Component.create('MainMenu', {
  // в этот объект можно записать свои методы
})
```
Каждый компонент получит следующие свойства:

- *this.controller* - ссылка на объект-контроллер, который управляет компонентов;
- *this.el* - ссылка на корневой DOM-элемент;
- *this.$el* - ссылка на корневой DOM-элемент, обернутый в Jquery-объект;
- *this.options* - объект с опциями, переданными компоненту при создании (опции передаются через объект в методе "onclick" корневого элемента)

## Собственные методы компонента

- **init()** - функция, которая будет запущена при создании компонента, предполагается, что пользователь переопределит эту функцию.
- **hideOverlay(forMobile)** - при необходимости создает блок с id и css-классом "overlay" и добавляет ему css-класс 'active', разные компоненты имеют дело с одним единственным блоком, два и более блока создаться не может. Если передать аргумент true (или для выразительности, например, строку "for mobile" - важно само наличие аргумента) в метод, то будет создан блок с id и css-классом "overlay_mobile". Предполагается его использование только на мобильных устройствах. Внешний вид и поведение блоков определяются пользователем в и css-стилях, компонент только создает блоки.
_forMobile_ (любое значение, приводящееся к true) - создать мобильную версию оверлея
- **showOverlay(forMobile)** - скрывает (удаляет css-класс 'active'). Аналогично методу hideOverlay, если передать аргумент, то метода будет управлять блоком для мобильных устройств.
_forMobile_ (любое значение, приводящееся к true) - создать мобильную версию оверлея
- **bindingEvent** - 
- **dataEvent** -

## Инициализация компонента

Инициализация компонента происходит автоматически. Контроллер ищет внутри своего корневого элемента DOM-узлы со свойством "data-component", получает из него имя класса компонента и создает экземпляр этого класса. В свойства экземпляру будут записаны: ссылка на контроллер, ссылка на DOM-элемент и объект с опциями. Этот объект задается в функцию "onclick" корневоого элемента. 
Пример элемента, который будет связан с компонентом "ComponentName":

`<div data-component="ComponentName" onclick="return {option: value}"></div>`

Создать экземпляр класса можно и вручную, если для этого возникнет необходимость. Все классы лежат в ассоциативном массиве *Controller.components* под своими именами. Так класс "ComponentName" можно вызвать, обратившись к нему **Controller.components["ComponentName"]**. 

## Создание контроллера

Контроллер - это функция, принимающая два аргумента. 
Первый необязательный аргумент - DOM-элемент, с которым связан контроллер, он будет доступен в свойствах *this.el* и *this.$el* (в Jquery-обертке). **Внимание!** Создание вложенных контроллеров невозможно. То есть внутри корневого элемента контроллера не должно быть элементов, связанных с другими контроллерами. Если первый аргумент не передан, то в контроллер будет работать с объектом document.
Второй, обязательный, аргумент - функция, в которую пользователь пишет свой код. 
Пример создания контроллера:

```sh
new Controller($(document), function(){
// здесь устанавливаются обработчики события и триггеры
})
```

## Методы контроллера

- **findBlocks($jqueryObject)** - ищет внутри переданного в единственном аргументе DOM-элемента (в Jquery-обертке) DOM-узлы со свойством "data-component" и сохраняет их в ассоциативном массиве *Controller.blocks*. В процессе запускает статический метод *Controller.createClassInstanses*, который попытается создать соответствующие компоненты, при наличии нужных классов в ассоциативном массиве *Controller.components*.
- **trigger(name, type, data)** - генерирует пользовательское событие. 
_name_ (строка) - имя события, обязательный аргумент
_type_ (строка или null) - тип события, обязательный аргумент, при наличии третьего аргумента, в противном случае не обязательный
_data_ (произвольный тип) - данные, которые будут переданы в обработчик события, необязательный аргумент
- **on(name, type, func, context)** - устанавливает обработчик на пользовательское событие.
_name_ (строка) - имя события, обязательный аргумент
_type_ (строка) - тип события, необязательный аргумент
_func_ - функция, которая будет выполнена при срабатывании события, обязательный аргумент
_context_ (объект) - контекст, в котором будет выполнана переданная функция, необязательный аргумент
- **stopListening(name, func, type)** - удаляет обработчик пользовательского события
_name_ (строка) - имя события, обязательный аргумент
_type_ (строка или null) - тип события, обязательный аргумент 
_func_ - функция, привязанная к событию, обязательный аргумент
- **set(object, bool)** - устанавливает новое значение свойства контроллера, если свойства не существует, то оно будет создано с переданным значением. Метод так же может сгенерировать пользовательское событие 'change' с типом 'имя_измененного_свойства'. В одном вызове можно передать несколько свойств.
_object_ (ассоциативный массив) - объект, типа { имя_свойства: 'новое значение' }
_bool_ - (булево значение) - если передать true, то событие, извещающее об изменениее свойства, сгенерировано не будет


